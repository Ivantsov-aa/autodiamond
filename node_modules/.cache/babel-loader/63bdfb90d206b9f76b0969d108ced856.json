{"ast":null,"code":"import { d as _inherits, e as _createSuper, a as _classCallCheck, _ as _createClass, g as _get, h as _getPrototypeOf, b as _objectWithoutProperties, i as _set } from '../_rollupPluginBabelHelpers-b054ecd2.js';\nimport { DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\nvar _excluded = [\"_blocks\"];\n/**\r\n  Pattern mask\r\n  @param {Object} opts\r\n  @param {Object} opts.blocks\r\n  @param {Object} opts.definitions\r\n  @param {string} opts.placeholderChar\r\n  @param {boolean} opts.lazy\r\n*/\n\nvar MaskedPattern = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedPattern, _Masked);\n\n  var _super = _createSuper(MaskedPattern);\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Show placeholder only when needed */\n\n\n  function MaskedPattern() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MaskedPattern); // TODO type $Shape<MaskedPatternOptions>={} does not work\n\n\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    return _super.call(this, Object.assign({}, MaskedPattern.DEFAULTS, opts));\n  }\n  /**\r\n    @override\r\n    @param {Object} opts\r\n  */\n\n\n  _createClass(MaskedPattern, [{\n    key: \"_update\",\n    value: function _update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"_update\", this).call(this, opts);\n\n      this._rebuildMask();\n    }\n    /** */\n\n  }, {\n    key: \"_rebuildMask\",\n    value: function _rebuildMask() {\n      var _this = this;\n\n      var defs = this.definitions;\n      this._blocks = [];\n      this._stops = [];\n      this._maskedBlocks = {};\n      var pattern = this.mask;\n      if (!pattern || !defs) return;\n      var unmaskingBlock = false;\n      var optionalBlock = false;\n\n      for (var i = 0; i < pattern.length; ++i) {\n        if (this.blocks) {\n          var _ret = function () {\n            var p = pattern.slice(i);\n            var bNames = Object.keys(_this.blocks).filter(function (bName) {\n              return p.indexOf(bName) === 0;\n            }); // order by key length\n\n            bNames.sort(function (a, b) {\n              return b.length - a.length;\n            }); // use block name with max length\n\n            var bName = bNames[0];\n\n            if (bName) {\n              // $FlowFixMe no ideas\n              var maskedBlock = createMask(Object.assign({\n                parent: _this,\n                lazy: _this.lazy,\n                eager: _this.eager,\n                placeholderChar: _this.placeholderChar,\n                overwrite: _this.overwrite\n              }, _this.blocks[bName]));\n\n              if (maskedBlock) {\n                _this._blocks.push(maskedBlock); // store block index\n\n\n                if (!_this._maskedBlocks[bName]) _this._maskedBlocks[bName] = [];\n\n                _this._maskedBlocks[bName].push(_this._blocks.length - 1);\n              }\n\n              i += bName.length - 1;\n              return \"continue\";\n            }\n          }();\n\n          if (_ret === \"continue\") continue;\n        }\n\n        var char = pattern[i];\n        var isInput = (char in defs);\n\n        if (char === MaskedPattern.STOP_CHAR) {\n          this._stops.push(this._blocks.length);\n\n          continue;\n        }\n\n        if (char === '{' || char === '}') {\n          unmaskingBlock = !unmaskingBlock;\n          continue;\n        }\n\n        if (char === '[' || char === ']') {\n          optionalBlock = !optionalBlock;\n          continue;\n        }\n\n        if (char === MaskedPattern.ESCAPE_CHAR) {\n          ++i;\n          char = pattern[i];\n          if (!char) break;\n          isInput = false;\n        }\n\n        var def = isInput ? new PatternInputDefinition({\n          parent: this,\n          lazy: this.lazy,\n          eager: this.eager,\n          placeholderChar: this.placeholderChar,\n          mask: defs[char],\n          isOptional: optionalBlock\n        }) : new PatternFixedDefinition({\n          char: char,\n          eager: this.eager,\n          isUnmasking: unmaskingBlock\n        });\n\n        this._blocks.push(def);\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return Object.assign({}, _get(_getPrototypeOf(MaskedPattern.prototype), \"state\", this), {\n        _blocks: this._blocks.map(function (b) {\n          return b.state;\n        })\n      });\n    },\n    set: function set(state) {\n      var _blocks = state._blocks,\n          maskedState = _objectWithoutProperties(state, _excluded);\n\n      this._blocks.forEach(function (b, bi) {\n        return b.state = _blocks[bi];\n      });\n\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"state\", maskedState, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"reset\", this).call(this);\n\n      this._blocks.forEach(function (b) {\n        return b.reset();\n      });\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isComplete;\n      });\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"isFilled\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isFilled;\n      });\n    }\n  }, {\n    key: \"isFixed\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isFixed;\n      });\n    }\n  }, {\n    key: \"isOptional\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isOptional;\n      });\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      this._blocks.forEach(function (b) {\n        return b.doCommit();\n      });\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"doCommit\", this).call(this);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this._blocks.reduce(function (str, b) {\n        return str += b.unmaskedValue;\n      }, '');\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"unmaskedValue\", unmaskedValue, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      // TODO return _value when not in change?\n      return this._blocks.reduce(function (str, b) {\n        return str += b.value;\n      }, '');\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"value\", value, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      return _get(_getPrototypeOf(MaskedPattern.prototype), \"appendTail\", this).call(this, tail).aggregate(this._appendPlaceholder());\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"_appendEager\",\n    value: function _appendEager() {\n      var _this$_mapPosToBlock;\n\n      var details = new ChangeDetails();\n      var startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;\n      if (startBlockIndex == null) return details; // TODO test if it works for nested pattern masks\n\n      if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n\n      for (var bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n        var d = this._blocks[bi]._appendEager();\n\n        if (!d.inserted) break;\n        details.aggregate(d);\n      }\n\n      return details;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var blockIter = this._mapPosToBlock(this.value.length);\n\n      var details = new ChangeDetails();\n      if (!blockIter) return details;\n\n      for (var bi = blockIter.index;; ++bi) {\n        var _flags$_beforeTailSta;\n\n        var _block = this._blocks[bi];\n        if (!_block) break;\n\n        var blockDetails = _block._appendChar(ch, Object.assign({}, flags, {\n          _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : _flags$_beforeTailSta._blocks[bi]\n        }));\n\n        var skip = blockDetails.skip;\n        details.aggregate(blockDetails);\n        if (skip || blockDetails.rawInserted) break; // go next char\n      }\n\n      return details;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var _this2 = this;\n\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var chunkTail = new ChunksTailDetails();\n      if (fromPos === toPos) return chunkTail;\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, bi, bFromPos, bToPos) {\n        var blockChunk = b.extractTail(bFromPos, bToPos);\n        blockChunk.stop = _this2._findStopBefore(bi);\n        blockChunk.from = _this2._blockStartPos(bi);\n        if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n        chunkTail.extend(blockChunk);\n      });\n\n      return chunkTail;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (fromPos === toPos) return '';\n      var input = '';\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, fromPos, toPos) {\n        input += b.extractInput(fromPos, toPos, flags);\n      });\n\n      return input;\n    }\n  }, {\n    key: \"_findStopBefore\",\n    value: function _findStopBefore(blockIndex) {\n      var stopBefore;\n\n      for (var si = 0; si < this._stops.length; ++si) {\n        var stop = this._stops[si];\n        if (stop <= blockIndex) stopBefore = stop;else break;\n      }\n\n      return stopBefore;\n    }\n    /** Appends placeholder depending on laziness */\n\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder(toBlockIndex) {\n      var _this3 = this;\n\n      var details = new ChangeDetails();\n      if (this.lazy && toBlockIndex == null) return details;\n\n      var startBlockIter = this._mapPosToBlock(this.value.length);\n\n      if (!startBlockIter) return details;\n      var startBlockIndex = startBlockIter.index;\n      var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n\n      this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function (b) {\n        if (!b.lazy || toBlockIndex != null) {\n          // $FlowFixMe `_blocks` may not be present\n          var args = b._blocks != null ? [b._blocks.length] : [];\n\n          var bDetails = b._appendPlaceholder.apply(b, args);\n\n          _this3._value += bDetails.inserted;\n          details.aggregate(bDetails);\n        }\n      });\n\n      return details;\n    }\n    /** Finds block in pos */\n\n  }, {\n    key: \"_mapPosToBlock\",\n    value: function _mapPosToBlock(pos) {\n      var accVal = '';\n\n      for (var bi = 0; bi < this._blocks.length; ++bi) {\n        var _block2 = this._blocks[bi];\n        var blockStartPos = accVal.length;\n        accVal += _block2.value;\n\n        if (pos <= accVal.length) {\n          return {\n            index: bi,\n            offset: pos - blockStartPos\n          };\n        }\n      }\n    }\n    /** */\n\n  }, {\n    key: \"_blockStartPos\",\n    value: function _blockStartPos(blockIndex) {\n      return this._blocks.slice(0, blockIndex).reduce(function (pos, b) {\n        return pos += b.value.length;\n      }, 0);\n    }\n    /** */\n\n  }, {\n    key: \"_forEachBlocksInRange\",\n    value: function _forEachBlocksInRange(fromPos) {\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var fn = arguments.length > 2 ? arguments[2] : undefined;\n\n      var fromBlockIter = this._mapPosToBlock(fromPos);\n\n      if (fromBlockIter) {\n        var toBlockIter = this._mapPosToBlock(toPos); // process first block\n\n\n        var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n        var fromBlockStartPos = fromBlockIter.offset;\n        var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n        fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n\n        if (toBlockIter && !isSameBlock) {\n          // process intermediate blocks\n          for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n            fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n          } // process last block\n\n\n          fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n        }\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n      var removeDetails = _get(_getPrototypeOf(MaskedPattern.prototype), \"remove\", this).call(this, fromPos, toPos);\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, bFromPos, bToPos) {\n        removeDetails.aggregate(b.remove(bFromPos, bToPos));\n      });\n\n      return removeDetails;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos(cursorPos) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n      if (!this._blocks.length) return 0;\n      var cursor = new PatternCursor(this, cursorPos);\n\n      if (direction === DIRECTION.NONE) {\n        // -------------------------------------------------\n        // NONE should only go out from fixed to the right!\n        // -------------------------------------------------\n        if (cursor.pushRightBeforeInput()) return cursor.pos;\n        cursor.popState();\n        if (cursor.pushLeftBeforeInput()) return cursor.pos;\n        return this.value.length;\n      } // FORCE is only about a|* otherwise is 0\n\n\n      if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n        // try to break fast when *|a\n        if (direction === DIRECTION.LEFT) {\n          cursor.pushRightBeforeFilled();\n          if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n          cursor.popState();\n        } // forward flow\n\n\n        cursor.pushLeftBeforeInput();\n        cursor.pushLeftBeforeRequired();\n        cursor.pushLeftBeforeFilled(); // backward flow\n\n        if (direction === DIRECTION.LEFT) {\n          cursor.pushRightBeforeInput();\n          cursor.pushRightBeforeRequired();\n          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n          cursor.popState();\n          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n          cursor.popState();\n        }\n\n        if (cursor.ok) return cursor.pos;\n        if (direction === DIRECTION.FORCE_LEFT) return 0;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos; // cursor.popState();\n        // if (\n        //   cursor.pushRightBeforeInput() &&\n        //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\n        //   (!this.lazy || this.extractInput())\n        // ) return cursor.pos;\n\n        return 0;\n      }\n\n      if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n        // forward flow\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.pushRightBeforeFilled()) return cursor.pos;\n        if (direction === DIRECTION.FORCE_RIGHT) return this.value.length; // backward flow\n\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n      }\n\n      return cursorPos;\n    }\n    /** Get block by name */\n\n  }, {\n    key: \"maskedBlock\",\n    value: function maskedBlock(name) {\n      return this.maskedBlocks(name)[0];\n    }\n    /** Get all blocks by name */\n\n  }, {\n    key: \"maskedBlocks\",\n    value: function maskedBlocks(name) {\n      var _this4 = this;\n\n      var indices = this._maskedBlocks[name];\n      if (!indices) return [];\n      return indices.map(function (gi) {\n        return _this4._blocks[gi];\n      });\n    }\n  }]);\n\n  return MaskedPattern;\n}(Masked);\n\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\nexport { MaskedPattern as default };","map":{"version":3,"names":["d","_inherits","e","_createSuper","a","_classCallCheck","_","_createClass","g","_get","h","_getPrototypeOf","b","_objectWithoutProperties","i","_set","DIRECTION","ChangeDetails","Masked","PatternInputDefinition","DEFAULT_INPUT_DEFINITIONS","PatternFixedDefinition","ChunksTailDetails","PatternCursor","createMask","IMask","_excluded","MaskedPattern","_Masked","_super","opts","arguments","length","undefined","definitions","Object","assign","call","DEFAULTS","key","value","_update","prototype","_rebuildMask","_this","defs","_blocks","_stops","_maskedBlocks","pattern","mask","unmaskingBlock","optionalBlock","blocks","_ret","p","slice","bNames","keys","filter","bName","indexOf","sort","maskedBlock","parent","lazy","eager","placeholderChar","overwrite","push","char","isInput","STOP_CHAR","ESCAPE_CHAR","def","isOptional","isUnmasking","get","map","state","set","maskedState","forEach","bi","reset","every","isComplete","isFilled","isFixed","doCommit","reduce","str","unmaskedValue","appendTail","tail","aggregate","_appendPlaceholder","_appendEager","_this$_mapPosToBlock","details","startBlockIndex","_mapPosToBlock","index","inserted","_appendCharRaw","ch","flags","blockIter","_flags$_beforeTailSta","_block","blockDetails","_appendChar","_beforeTailState","skip","rawInserted","extractTail","_this2","fromPos","toPos","chunkTail","_forEachBlocksInRange","bFromPos","bToPos","blockChunk","stop","_findStopBefore","from","_blockStartPos","blockIndex","extend","extractInput","input","stopBefore","si","toBlockIndex","_this3","startBlockIter","endBlockIndex","args","bDetails","apply","_value","pos","accVal","_block2","blockStartPos","offset","fn","fromBlockIter","toBlockIter","isSameBlock","fromBlockStartPos","fromBlockEndPos","remove","removeDetails","nearestInputPos","cursorPos","direction","NONE","cursor","pushRightBeforeInput","popState","pushLeftBeforeInput","LEFT","FORCE_LEFT","pushRightBeforeFilled","ok","pushLeftBeforeRequired","pushLeftBeforeFilled","pushRightBeforeRequired","RIGHT","FORCE_RIGHT","name","maskedBlocks","_this4","indices","gi","InputDefinition","FixedDefinition","default"],"sources":["C:/front/autodiamond/node_modules/imask/esm/masked/pattern.js"],"sourcesContent":["import { d as _inherits, e as _createSuper, a as _classCallCheck, _ as _createClass, g as _get, h as _getPrototypeOf, b as _objectWithoutProperties, i as _set } from '../_rollupPluginBabelHelpers-b054ecd2.js';\r\nimport { DIRECTION } from '../core/utils.js';\r\nimport ChangeDetails from '../core/change-details.js';\r\nimport Masked from './base.js';\r\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\r\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\r\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\r\nimport PatternCursor from './pattern/cursor.js';\r\nimport createMask from './factory.js';\r\nimport IMask from '../core/holder.js';\r\nimport './regexp.js';\r\nimport '../core/continuous-tail-details.js';\r\n\r\nvar _excluded = [\"_blocks\"];\r\n\r\n/**\r\n  Pattern mask\r\n  @param {Object} opts\r\n  @param {Object} opts.blocks\r\n  @param {Object} opts.definitions\r\n  @param {string} opts.placeholderChar\r\n  @param {boolean} opts.lazy\r\n*/\r\nvar MaskedPattern = /*#__PURE__*/function (_Masked) {\r\n  _inherits(MaskedPattern, _Masked);\r\n\r\n  var _super = _createSuper(MaskedPattern);\r\n\r\n  /** */\r\n\r\n  /** */\r\n\r\n  /** Single char for empty input */\r\n\r\n  /** Show placeholder only when needed */\r\n  function MaskedPattern() {\r\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n\r\n    _classCallCheck(this, MaskedPattern);\r\n\r\n    // TODO type $Shape<MaskedPatternOptions>={} does not work\r\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\r\n    return _super.call(this, Object.assign({}, MaskedPattern.DEFAULTS, opts));\r\n  }\r\n  /**\r\n    @override\r\n    @param {Object} opts\r\n  */\r\n\r\n\r\n  _createClass(MaskedPattern, [{\r\n    key: \"_update\",\r\n    value: function _update() {\r\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n      opts.definitions = Object.assign({}, this.definitions, opts.definitions);\r\n\r\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"_update\", this).call(this, opts);\r\n\r\n      this._rebuildMask();\r\n    }\r\n    /** */\r\n\r\n  }, {\r\n    key: \"_rebuildMask\",\r\n    value: function _rebuildMask() {\r\n      var _this = this;\r\n\r\n      var defs = this.definitions;\r\n      this._blocks = [];\r\n      this._stops = [];\r\n      this._maskedBlocks = {};\r\n      var pattern = this.mask;\r\n      if (!pattern || !defs) return;\r\n      var unmaskingBlock = false;\r\n      var optionalBlock = false;\r\n\r\n      for (var i = 0; i < pattern.length; ++i) {\r\n        if (this.blocks) {\r\n          var _ret = function () {\r\n            var p = pattern.slice(i);\r\n            var bNames = Object.keys(_this.blocks).filter(function (bName) {\r\n              return p.indexOf(bName) === 0;\r\n            }); // order by key length\r\n\r\n            bNames.sort(function (a, b) {\r\n              return b.length - a.length;\r\n            }); // use block name with max length\r\n\r\n            var bName = bNames[0];\r\n\r\n            if (bName) {\r\n              // $FlowFixMe no ideas\r\n              var maskedBlock = createMask(Object.assign({\r\n                parent: _this,\r\n                lazy: _this.lazy,\r\n                eager: _this.eager,\r\n                placeholderChar: _this.placeholderChar,\r\n                overwrite: _this.overwrite\r\n              }, _this.blocks[bName]));\r\n\r\n              if (maskedBlock) {\r\n                _this._blocks.push(maskedBlock); // store block index\r\n\r\n\r\n                if (!_this._maskedBlocks[bName]) _this._maskedBlocks[bName] = [];\r\n\r\n                _this._maskedBlocks[bName].push(_this._blocks.length - 1);\r\n              }\r\n\r\n              i += bName.length - 1;\r\n              return \"continue\";\r\n            }\r\n          }();\r\n\r\n          if (_ret === \"continue\") continue;\r\n        }\r\n\r\n        var char = pattern[i];\r\n        var isInput = (char in defs);\r\n\r\n        if (char === MaskedPattern.STOP_CHAR) {\r\n          this._stops.push(this._blocks.length);\r\n\r\n          continue;\r\n        }\r\n\r\n        if (char === '{' || char === '}') {\r\n          unmaskingBlock = !unmaskingBlock;\r\n          continue;\r\n        }\r\n\r\n        if (char === '[' || char === ']') {\r\n          optionalBlock = !optionalBlock;\r\n          continue;\r\n        }\r\n\r\n        if (char === MaskedPattern.ESCAPE_CHAR) {\r\n          ++i;\r\n          char = pattern[i];\r\n          if (!char) break;\r\n          isInput = false;\r\n        }\r\n\r\n        var def = isInput ? new PatternInputDefinition({\r\n          parent: this,\r\n          lazy: this.lazy,\r\n          eager: this.eager,\r\n          placeholderChar: this.placeholderChar,\r\n          mask: defs[char],\r\n          isOptional: optionalBlock\r\n        }) : new PatternFixedDefinition({\r\n          char: char,\r\n          eager: this.eager,\r\n          isUnmasking: unmaskingBlock\r\n        });\r\n\r\n        this._blocks.push(def);\r\n      }\r\n    }\r\n    /**\r\n      @override\r\n    */\r\n\r\n  }, {\r\n    key: \"state\",\r\n    get: function get() {\r\n      return Object.assign({}, _get(_getPrototypeOf(MaskedPattern.prototype), \"state\", this), {\r\n        _blocks: this._blocks.map(function (b) {\r\n          return b.state;\r\n        })\r\n      });\r\n    },\r\n    set: function set(state) {\r\n      var _blocks = state._blocks,\r\n          maskedState = _objectWithoutProperties(state, _excluded);\r\n\r\n      this._blocks.forEach(function (b, bi) {\r\n        return b.state = _blocks[bi];\r\n      });\r\n\r\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"state\", maskedState, this, true);\r\n    }\r\n    /**\r\n      @override\r\n    */\r\n\r\n  }, {\r\n    key: \"reset\",\r\n    value: function reset() {\r\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"reset\", this).call(this);\r\n\r\n      this._blocks.forEach(function (b) {\r\n        return b.reset();\r\n      });\r\n    }\r\n    /**\r\n      @override\r\n    */\r\n\r\n  }, {\r\n    key: \"isComplete\",\r\n    get: function get() {\r\n      return this._blocks.every(function (b) {\r\n        return b.isComplete;\r\n      });\r\n    }\r\n    /**\r\n      @override\r\n    */\r\n\r\n  }, {\r\n    key: \"isFilled\",\r\n    get: function get() {\r\n      return this._blocks.every(function (b) {\r\n        return b.isFilled;\r\n      });\r\n    }\r\n  }, {\r\n    key: \"isFixed\",\r\n    get: function get() {\r\n      return this._blocks.every(function (b) {\r\n        return b.isFixed;\r\n      });\r\n    }\r\n  }, {\r\n    key: \"isOptional\",\r\n    get: function get() {\r\n      return this._blocks.every(function (b) {\r\n        return b.isOptional;\r\n      });\r\n    }\r\n    /**\r\n      @override\r\n    */\r\n\r\n  }, {\r\n    key: \"doCommit\",\r\n    value: function doCommit() {\r\n      this._blocks.forEach(function (b) {\r\n        return b.doCommit();\r\n      });\r\n\r\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"doCommit\", this).call(this);\r\n    }\r\n    /**\r\n      @override\r\n    */\r\n\r\n  }, {\r\n    key: \"unmaskedValue\",\r\n    get: function get() {\r\n      return this._blocks.reduce(function (str, b) {\r\n        return str += b.unmaskedValue;\r\n      }, '');\r\n    },\r\n    set: function set(unmaskedValue) {\r\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"unmaskedValue\", unmaskedValue, this, true);\r\n    }\r\n    /**\r\n      @override\r\n    */\r\n\r\n  }, {\r\n    key: \"value\",\r\n    get: function get() {\r\n      // TODO return _value when not in change?\r\n      return this._blocks.reduce(function (str, b) {\r\n        return str += b.value;\r\n      }, '');\r\n    },\r\n    set: function set(value) {\r\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"value\", value, this, true);\r\n    }\r\n    /**\r\n      @override\r\n    */\r\n\r\n  }, {\r\n    key: \"appendTail\",\r\n    value: function appendTail(tail) {\r\n      return _get(_getPrototypeOf(MaskedPattern.prototype), \"appendTail\", this).call(this, tail).aggregate(this._appendPlaceholder());\r\n    }\r\n    /**\r\n      @override\r\n    */\r\n\r\n  }, {\r\n    key: \"_appendEager\",\r\n    value: function _appendEager() {\r\n      var _this$_mapPosToBlock;\r\n\r\n      var details = new ChangeDetails();\r\n      var startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;\r\n      if (startBlockIndex == null) return details; // TODO test if it works for nested pattern masks\r\n\r\n      if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\r\n\r\n      for (var bi = startBlockIndex; bi < this._blocks.length; ++bi) {\r\n        var d = this._blocks[bi]._appendEager();\r\n\r\n        if (!d.inserted) break;\r\n        details.aggregate(d);\r\n      }\r\n\r\n      return details;\r\n    }\r\n    /**\r\n      @override\r\n    */\r\n\r\n  }, {\r\n    key: \"_appendCharRaw\",\r\n    value: function _appendCharRaw(ch) {\r\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n\r\n      var blockIter = this._mapPosToBlock(this.value.length);\r\n\r\n      var details = new ChangeDetails();\r\n      if (!blockIter) return details;\r\n\r\n      for (var bi = blockIter.index;; ++bi) {\r\n        var _flags$_beforeTailSta;\r\n\r\n        var _block = this._blocks[bi];\r\n        if (!_block) break;\r\n\r\n        var blockDetails = _block._appendChar(ch, Object.assign({}, flags, {\r\n          _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : _flags$_beforeTailSta._blocks[bi]\r\n        }));\r\n\r\n        var skip = blockDetails.skip;\r\n        details.aggregate(blockDetails);\r\n        if (skip || blockDetails.rawInserted) break; // go next char\r\n      }\r\n\r\n      return details;\r\n    }\r\n    /**\r\n      @override\r\n    */\r\n\r\n  }, {\r\n    key: \"extractTail\",\r\n    value: function extractTail() {\r\n      var _this2 = this;\r\n\r\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\r\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\r\n      var chunkTail = new ChunksTailDetails();\r\n      if (fromPos === toPos) return chunkTail;\r\n\r\n      this._forEachBlocksInRange(fromPos, toPos, function (b, bi, bFromPos, bToPos) {\r\n        var blockChunk = b.extractTail(bFromPos, bToPos);\r\n        blockChunk.stop = _this2._findStopBefore(bi);\r\n        blockChunk.from = _this2._blockStartPos(bi);\r\n        if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\r\n        chunkTail.extend(blockChunk);\r\n      });\r\n\r\n      return chunkTail;\r\n    }\r\n    /**\r\n      @override\r\n    */\r\n\r\n  }, {\r\n    key: \"extractInput\",\r\n    value: function extractInput() {\r\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\r\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\r\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n      if (fromPos === toPos) return '';\r\n      var input = '';\r\n\r\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, fromPos, toPos) {\r\n        input += b.extractInput(fromPos, toPos, flags);\r\n      });\r\n\r\n      return input;\r\n    }\r\n  }, {\r\n    key: \"_findStopBefore\",\r\n    value: function _findStopBefore(blockIndex) {\r\n      var stopBefore;\r\n\r\n      for (var si = 0; si < this._stops.length; ++si) {\r\n        var stop = this._stops[si];\r\n        if (stop <= blockIndex) stopBefore = stop;else break;\r\n      }\r\n\r\n      return stopBefore;\r\n    }\r\n    /** Appends placeholder depending on laziness */\r\n\r\n  }, {\r\n    key: \"_appendPlaceholder\",\r\n    value: function _appendPlaceholder(toBlockIndex) {\r\n      var _this3 = this;\r\n\r\n      var details = new ChangeDetails();\r\n      if (this.lazy && toBlockIndex == null) return details;\r\n\r\n      var startBlockIter = this._mapPosToBlock(this.value.length);\r\n\r\n      if (!startBlockIter) return details;\r\n      var startBlockIndex = startBlockIter.index;\r\n      var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\r\n\r\n      this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function (b) {\r\n        if (!b.lazy || toBlockIndex != null) {\r\n          // $FlowFixMe `_blocks` may not be present\r\n          var args = b._blocks != null ? [b._blocks.length] : [];\r\n\r\n          var bDetails = b._appendPlaceholder.apply(b, args);\r\n\r\n          _this3._value += bDetails.inserted;\r\n          details.aggregate(bDetails);\r\n        }\r\n      });\r\n\r\n      return details;\r\n    }\r\n    /** Finds block in pos */\r\n\r\n  }, {\r\n    key: \"_mapPosToBlock\",\r\n    value: function _mapPosToBlock(pos) {\r\n      var accVal = '';\r\n\r\n      for (var bi = 0; bi < this._blocks.length; ++bi) {\r\n        var _block2 = this._blocks[bi];\r\n        var blockStartPos = accVal.length;\r\n        accVal += _block2.value;\r\n\r\n        if (pos <= accVal.length) {\r\n          return {\r\n            index: bi,\r\n            offset: pos - blockStartPos\r\n          };\r\n        }\r\n      }\r\n    }\r\n    /** */\r\n\r\n  }, {\r\n    key: \"_blockStartPos\",\r\n    value: function _blockStartPos(blockIndex) {\r\n      return this._blocks.slice(0, blockIndex).reduce(function (pos, b) {\r\n        return pos += b.value.length;\r\n      }, 0);\r\n    }\r\n    /** */\r\n\r\n  }, {\r\n    key: \"_forEachBlocksInRange\",\r\n    value: function _forEachBlocksInRange(fromPos) {\r\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\r\n      var fn = arguments.length > 2 ? arguments[2] : undefined;\r\n\r\n      var fromBlockIter = this._mapPosToBlock(fromPos);\r\n\r\n      if (fromBlockIter) {\r\n        var toBlockIter = this._mapPosToBlock(toPos); // process first block\r\n\r\n\r\n        var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\r\n        var fromBlockStartPos = fromBlockIter.offset;\r\n        var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\r\n        fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\r\n\r\n        if (toBlockIter && !isSameBlock) {\r\n          // process intermediate blocks\r\n          for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\r\n            fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\r\n          } // process last block\r\n\r\n\r\n          fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\r\n        }\r\n      }\r\n    }\r\n    /**\r\n      @override\r\n    */\r\n\r\n  }, {\r\n    key: \"remove\",\r\n    value: function remove() {\r\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\r\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\r\n\r\n      var removeDetails = _get(_getPrototypeOf(MaskedPattern.prototype), \"remove\", this).call(this, fromPos, toPos);\r\n\r\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, bFromPos, bToPos) {\r\n        removeDetails.aggregate(b.remove(bFromPos, bToPos));\r\n      });\r\n\r\n      return removeDetails;\r\n    }\r\n    /**\r\n      @override\r\n    */\r\n\r\n  }, {\r\n    key: \"nearestInputPos\",\r\n    value: function nearestInputPos(cursorPos) {\r\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\r\n      if (!this._blocks.length) return 0;\r\n      var cursor = new PatternCursor(this, cursorPos);\r\n\r\n      if (direction === DIRECTION.NONE) {\r\n        // -------------------------------------------------\r\n        // NONE should only go out from fixed to the right!\r\n        // -------------------------------------------------\r\n        if (cursor.pushRightBeforeInput()) return cursor.pos;\r\n        cursor.popState();\r\n        if (cursor.pushLeftBeforeInput()) return cursor.pos;\r\n        return this.value.length;\r\n      } // FORCE is only about a|* otherwise is 0\r\n\r\n\r\n      if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\r\n        // try to break fast when *|a\r\n        if (direction === DIRECTION.LEFT) {\r\n          cursor.pushRightBeforeFilled();\r\n          if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\r\n          cursor.popState();\r\n        } // forward flow\r\n\r\n\r\n        cursor.pushLeftBeforeInput();\r\n        cursor.pushLeftBeforeRequired();\r\n        cursor.pushLeftBeforeFilled(); // backward flow\r\n\r\n        if (direction === DIRECTION.LEFT) {\r\n          cursor.pushRightBeforeInput();\r\n          cursor.pushRightBeforeRequired();\r\n          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\r\n          cursor.popState();\r\n          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\r\n          cursor.popState();\r\n        }\r\n\r\n        if (cursor.ok) return cursor.pos;\r\n        if (direction === DIRECTION.FORCE_LEFT) return 0;\r\n        cursor.popState();\r\n        if (cursor.ok) return cursor.pos;\r\n        cursor.popState();\r\n        if (cursor.ok) return cursor.pos; // cursor.popState();\r\n        // if (\r\n        //   cursor.pushRightBeforeInput() &&\r\n        //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\r\n        //   (!this.lazy || this.extractInput())\r\n        // ) return cursor.pos;\r\n\r\n        return 0;\r\n      }\r\n\r\n      if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\r\n        // forward flow\r\n        cursor.pushRightBeforeInput();\r\n        cursor.pushRightBeforeRequired();\r\n        if (cursor.pushRightBeforeFilled()) return cursor.pos;\r\n        if (direction === DIRECTION.FORCE_RIGHT) return this.value.length; // backward flow\r\n\r\n        cursor.popState();\r\n        if (cursor.ok) return cursor.pos;\r\n        cursor.popState();\r\n        if (cursor.ok) return cursor.pos;\r\n        return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\r\n      }\r\n\r\n      return cursorPos;\r\n    }\r\n    /** Get block by name */\r\n\r\n  }, {\r\n    key: \"maskedBlock\",\r\n    value: function maskedBlock(name) {\r\n      return this.maskedBlocks(name)[0];\r\n    }\r\n    /** Get all blocks by name */\r\n\r\n  }, {\r\n    key: \"maskedBlocks\",\r\n    value: function maskedBlocks(name) {\r\n      var _this4 = this;\r\n\r\n      var indices = this._maskedBlocks[name];\r\n      if (!indices) return [];\r\n      return indices.map(function (gi) {\r\n        return _this4._blocks[gi];\r\n      });\r\n    }\r\n  }]);\r\n\r\n  return MaskedPattern;\r\n}(Masked);\r\nMaskedPattern.DEFAULTS = {\r\n  lazy: true,\r\n  placeholderChar: '_'\r\n};\r\nMaskedPattern.STOP_CHAR = '`';\r\nMaskedPattern.ESCAPE_CHAR = '\\\\';\r\nMaskedPattern.InputDefinition = PatternInputDefinition;\r\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\r\nIMask.MaskedPattern = MaskedPattern;\r\n\r\nexport { MaskedPattern as default };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}